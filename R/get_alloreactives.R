#' Define Alloreactive TCR Sequences
#'
#' Determine alloreactive TCR sequences from Immunoseq sequencing data of
#'   responding (CFSE Lo) T cells from an MLR and unstimulated T cells.
#'
#' This function automates the determination of alloreactive TCR sequences as
#'   documented in
#'   [Obradovic 2021](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8920412/).
#'   Input sequencing data must be of the same format as that returned by
#'   [cdr3tools::read_immunoseq]. At minimum two sequencing files are required:
#'   a FACS sorted responder population of T cells that were activated against
#'   target cells in a mixed lymphocyte reaction (usually stained with CFSE to
#'   track proliferation by FACS) and an unstimulated population
#'   of T cells from the same source as the responder T cells. Optionally, the
#'   function accepts separate files if CD4 and CD8 populations were FACS sorted
#'   from either or both of the input T cell populations. It should be noted that
#'   the Sykes Lab's convention is to use a 1e-5 frequency threshold for reads
#'   and 2e-5 for templates since Immunoseq uses a 1 copy cutoff for templates
#'   but not reads. The fold multiplier threshold convention is 2. However,
#'   users may supply their own values for these parameters.
#'
#' @param .cfselo An input data frame (or list of data frames) as generated by
#'   [cdr3tools::read_immunoseq()] corresponding to the MLR responder T cells,
#'   usually FACS sorted on the basis of being CFSE low. If there are separate
#'   files for CD4 and CD8 responders `.cfselo` may also be a named list of such
#'   data frames with format:
#'   `list(CD4 = CD4 data frame, CD8 = CD8 data frame)`.
#' @param .unstim An input data frame (or list of data frames) as generated by
#'   [cdr3tools::read_immunoseq()] corresponding to unstimulated T cells. If
#'   there are separate files for CD4 and CD8 unstimulated T cells `.unstim` may
#'   also be a named list of such data frames with format:
#'   `list(CD4 = CD4 data frame, CD8 = CD8 data frame)`.
#' @param .frequency Numeric. The repertoire template (or read) frequency
#'   threshold for which responder T cells must be greater than or equal to in
#'   order to be considered alloreactive. User may enter any numeric value, but
#'   please note our convention is to use 1e-5 for reads data and
#'   2e-5 for templates data due to copy number thresholds used by Immunoseq.
#' @param .fold Numeric. The multiplier defining the threshold for which
#'   responder T cells must be greater than or equal to the template (or read)
#'   frequency of a matching unstimulated T cells in order to be considered
#'   alloreactive. User may enter any numeric value, but please note our
#'   convention is to use 2.
#' @param .group_by Character. The combination of T cell receptor sequences and
#'   V and J genes to use in order to group unique sequences. If `NULL`, the
#'   default is to group unique sequences by CDR3 nucleotide sequence plus the
#'   most resolved V and J gene calls. Allowed inputs to `.group_by` are:
#'     \describe{
#'       \item{"nt"}{CDR3 nucleotide sequence}
#'       \item{"ntvj"}{*Default*. CDR3 nucleotide sequence plus most resolved V and J gene calls}
#'       \item{"aa"}{CDR3 amino acid sequence}
#'       \item{"aavj"}{CDR3 amino acid sequence plus most resolved V and J gene calls}
#'       \item{"rearrangement"}{full nucleotide sequence (not suitable for comparisons across platforms)}
#'       \item{"extended_rearrangement"}{extended full nucleotide sequence (not suitable for comparisons across platforms)}
#'       \item{"rearrangement_trunc"}{truncated full nucleotide sequence}
#'     }
#' @param .use_reads Logical. `FALSE` (the default) indicates that repertoire
#'   frequencies should be calculated using templates. `TRUE` indicates that
#'   repertoire frequencies should be calculated using reads. Immunoseq files
#'   are sometimes exported without reads information if templates are present
#'   in the data. In this case `cdr3tools::get_alloreactives()` will throw an
#'   error if `.use_reads` = TRUE.
#' @returns A data frame of alloreactive sequences. Columns defining unique
#'   alloreactive sequences are determined by the user set value to `.group_by`.
#'   Columns indicating the repertoire frequencies of each unique alloreactive
#'   sequence in the responding and unstimulated repertoires are also included.
#' @author Christopher Parks
#' @references
#' Obradovic A, Shen Y, Sykes M, Fu J. Integrated Analysis Toolset for Defining
#'   and Tracking Alloreactive T-cell Clones After Human Solid Organ and
#'   Hematopoietic Stem Cell Transplantation. Softw Impacts. 2021 Nov;10:100142.
#'   doi: 10.1016/j.simpa.2021.100142. Epub 2021 Sep 23. PMID: 35291378; PMCID:
#'   PMC8920412.
#' @examples
#' get_alloreactives(.cfselo = cfselo_seqs, .unstim = unstim_seqs)
#' @family Immunoseq
#' @export
get_alloreactives <- function(.cfselo, .unstim, .frequency = 2e-5, .fold = 2,
                              .group_by = NULL, .use_reads = NULL) {

  # processing args
  fold <- .fold

  if (is.null(.group_by)) .group_by <- "ntvj"
  .group_by <- rlang::arg_match(.group_by, c("nt", "ntvj", "aa", "aavj",
                                             "rearrangement",
                                             "rearrangement_trunc",
                                             "extended_rearrangement"))
  group_by <- switch(.group_by,
    nt                     = "cdr3_rearrangement",
    ntvj                   = c("cdr3_rearrangement", "v_resolved", "j_resolved"),
    aa                     = "cdr3_amino_acid",
    aavj                   = c("cdr3_amino_acid", "v_resolved", "j_resolved"),
    rearrangement          = "rearrangement",
    rearrangement_trunc    = "rearrangement_trunc",
    extended_rearrangement = "extended_rearrangement"
  )

  if (is.null(.use_reads)) .use_reads <- FALSE
  use_reads <- .use_reads
  frequency <- .frequency

  # # check for immunoseq v1 exported files
  # matches <- names(cfselo) %in% cdr3tools::immunoseq_export_v1_col_names
  # if (!all(matches)) {
  #   rlang::abort(
  #     paste(
  #       ".cfselo and .unstim must be data frames (or lists of data frames)",
  #       "as returned by the cdr3tools::read_immunoseq() function. Additionally,",
  #       "files read with cdr3tools::read_immunoseq() are required to be",
  #       "immunoseq export v1 .tsv files. See ?cdr3tools::read_immunoseq for",
  #       "details."
  #     )
  #   )
  # }


  if (inherits(.cfselo, "list") && length(.cfselo) == 2) {
    if (!all(methods::allNames(.cfselo) %in% c("CD4", "CD8"))) {
      rlang::abort(paste(
        "The input to .cfselo must be a named list with format",
        "list(CD4 = 'CFSE Lo CD4 data frame', CD8 = 'CFSE Lo CD8 data frame').",
        "If the CFSE Lo data are not separate CD4 and CD8 data frames,",
        "set .cfselo to the single data frame containing the CFSE Lo data."
        )
      )
    }
    cfselo_CD4 <- dtplyr::lazy_dt(.cfselo[[which(names(.cfselo) == "CD4")]], key_by = {{ group_by }})
    cfselo_CD8 <- dtplyr::lazy_dt(.cfselo[[which(names(.cfselo) == "CD8")]], key_by = {{ group_by }})
    # cfselo_CD4 <- data.table::as.data.table(.cfselo[[which(names(.cfselo) == "CD4")]])
    # cfselo_CD8 <- data.table::as.data.table(.cfselo[[which(names(.cfselo) == "CD8")]])
  } else if (inherits(.cfselo, "data.frame")) {
    cfselo <- dtplyr::lazy_dt(.cfselo, key_by = {{ group_by }})
    # cfselo <- data.table::as.data.table(.cfselo)
  } else rlang::abort("Valid input to .cfse not detected. See ?cdr3tools::get_alloreactives")

  if (inherits(.unstim, "list") && length(.unstim) == 2) {
    if (!all(methods::allNames(.unstim) %in% c("CD4", "CD8"))) {
      rlang::abort(paste(
        "The input to .unstim must be a named list with format",
        "list(CD4 = 'Unstim CD4 data frame', CD8 = 'Unstim CD8 data frame').",
        "If the Unstim data are not separate CD4 and CD8 data frames,",
        "set .unstim to the single data frame containing the Unstim data."
      )
      )
    }
    unstim_CD4 <- dtplyr::lazy_dt(.unstim[[which(names(.unstim) == "CD4")]], key_by = {{ group_by }})
    unstim_CD8 <- dtplyr::lazy_dt(.unstim[[which(names(.unstim) == "CD8")]], key_by = {{ group_by }})
    # unstim_CD4 <- data.table::as.data.table(.unstim[[which(names(.unstim) == "CD4")]])
    # unstim_CD8 <- data.table::as.data.table(.unstim[[which(names(.unstim) == "CD8")]])
  } else if (inherits(.unstim, "data.frame")) {
    unstim <- dtplyr::lazy_dt(.unstim, key_by = {{ group_by }})
    # unstim <- data.table::as.data.table(.unstim)
  } else rlang::abort("Valid input to .unstim not detected. See ?cdr3tools::get_alloreactives")

  data_input <- as.character(sum(which(vapply(
    X = c("cfselo", "cfselo_CD4", "cfselo_CD8", "unstim", "unstim_CD4", "unstim_CD8"),
    FUN = function(x) exists(x),
    FUN.VALUE = logical(1)
  ))))

  allo <- switch(data_input,
    `5`  = get_alloreactives_internal_1(cfselo, unstim,
                frequency, fold, group_by, use_reads),
    `12` = get_alloreactives_internal_2(cfselo, unstim_CD4, unstim_CD8,
                frequency, fold, group_by, use_reads),
    `9`  = get_alloreactives_internal_3(cfselo_CD4, cfselo_CD8, unstim,
                frequency, fold, group_by, use_reads),
    `16` = get_alloreactives_internal_4(cfselo_CD4, cfselo_CD8, unstim_CD4, unstim_CD8,
                frequency, fold, group_by, use_reads)
  )

  allo <- tibble::as_tibble(allo) %>%
    dplyr::arrange(dplyr::desc(.data$frequency.cfselo))
  return(allo)
}

get_alloreactives_internal_1 <- function(cfselo, unstim,
                   frequency, fold, group_by, use_reads) {

  if (use_reads) {

    if (all(is.na(cfselo$seq_reads)) || all(is.na(unstim$seq_reads))) {
      rlang::abort(".cfselo$seq_reads or .unstim$seq_reads have no values. Set .use_reads = FALSE to use templates.")
    }

    rlang::warn("Is the .frequency cutoff set to 1e-5? .frequency should be 1e-5 for reads and 2e-5 for templates.")

    cfselo <- cfselo %>%
      dplyr::select(-.data$templates) %>%
      dplyr::rename(templates = .data$seq_reads)

    unstim <- unstim %>%
      dplyr::select(-.data$templates) %>%
      dplyr::rename(templates = .data$seq_reads)
  }

  cfselo <- cfselo %>%
    dplyr::group_by(dplyr::across(tidyselect::all_of({{ group_by }}))) %>%
    dplyr::summarise(templates = sum(.data$templates)) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(frequency = .data$templates / sum(.data$templates)) %>%
    dplyr::select(-.data$templates)

  unstim <- unstim %>%
    dplyr::group_by(dplyr::across(tidyselect::all_of({{ group_by }}))) %>%
    dplyr::summarise(templates = sum(.data$templates)) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(frequency = .data$templates / sum(.data$templates)) %>%
    dplyr::select(-.data$templates)

  allo <- cfselo %>%
    dplyr::full_join(unstim, by = {{ group_by }}) %>%
    dplyr::rename(frequency.cfselo = .data$frequency.x,
                  frequency.unstim = .data$frequency.y) %>%
    dplyr::mutate(dplyr::across(tidyselect::matches("\\.cfselo|\\.unstim"),
                                ~ tidyr::replace_na(.x, 0))) %>%
    dplyr::filter(.data$frequency.cfselo >= {{ frequency }},
                  .data$frequency.cfselo >= {{ fold }} * .data$frequency.unstim)

  return(allo)
}

get_alloreactives_internal_2 <- function(cfselo, unstim_CD4, unstim_CD8,
                                         frequency, fold, group_by, use_reads) {}

get_alloreactives_internal_3 <- function(cfselo_CD4, cfselo_CD8, unstim,
                                         frequency, fold, group_by, use_reads) {}

get_alloreactives_internal_4 <- function(cfselo_CD4, cfselo_CD8, unstim_CD4, unstim_CD8,
                                         frequency, fold, group_by, use_reads) {}
